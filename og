#!/bin/bash

#
# Variables
#

# text
Cyan='\033[0;36m'
Yellow='\033[1;33m'
Red='\033[0;31m'
Orange='\033[0;33m'
Green='\033[0;32m'
NC='\033[0;0m'
EOL='\n'
SPACER='\n\n'
INDENT='    '
BOLD='\033[1m'
HAIR='\033[0m'
ITALIC='\033[3m'

REPO_URI='\e]8;;https://github.com/open-data/docker-og/\e\\Docker OG\e]8;;\e\\'
DOCKER_URI='\e]8;;https://docs.docker.com/get-docker/\e\\Docker\e]8;;\e\\'
COMPOSE_URI='\e]8;;https://docs.docker.com/compose/\e\\Docker Compose\e]8;;\e\\'
GIT_URI='\e]8;;https://git-scm.com/download/\e\\Git\e]8;;\e\\'
PRE_BUILD_URI='\e]8;;https://github.com/open-data/docker-og#prebuild\e\\configure local or global files and backups.\e]8;;\e\\'
projectID=''
projectDir='false'
dockerComposeCommand='docker compose'
validRepos="opengov og gcweb_bootstrap ogc_search ckan ckanapi ckanext-canada ckanext-cloudstorage ckanext-dcat ckanext-extendedactivity ckanext-extractor ckanext-fluent ckanext-recombinant ckanext-scheming ckanext-security ckanext-validation ckanext-xloader ckantoolkit goodtables ckanext-wet-boew"

function output_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og${HAIR} COMMAND${SPACER}"
    printf "${INDENT}Commands:${EOL}"
    printf "${INDENT}${INDENT}${BOLD}docker${HAIR}       Interfaces with the ${REPO_URI} repository.${SPACER}"
    printf "${INDENT}${INDENT}             Usage: ${BOLD}og docker${HAIR} COMMAND${SPACER}"
    printf "${INDENT}${INDENT}             Commands:${EOL}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}boot${HAIR}       Regerates hosts files, sets correct permissions for the docker socket, and restarts the docker service.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}init${HAIR}       Initializes a new ${REPO_URI} instance into a directory with the provided PROJECT ID. The PROJECT ID must be lowercase and contain only alphanumeric characters.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}           Usage: ${BOLD}og docker init${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}destroy${HAIR}    Deletes the project directory, docker images, and docker networks for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}           Usage: ${BOLD}og docker destroy${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}clone${HAIR}      Clones the source project directory, databases, and solr indices for the given source PROJECT ID to the new target PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}           Usage: ${BOLD}og docker clone${HAIR} [SOURCE PROJECT ID] [TARGET PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}build${HAIR}      Builds all of the docker containers for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}           Usage: ${BOLD}og docker build${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}[PROJECT ID] install [container]${HAIR}           Executes the installaion script for the given PROJECT ID and container.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID] install${HAIR} [drupal|django|ckan|ckanapi]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}[PROJECT ID] git [command]${HAIR}                 Runs git tooling for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID] git${HAIR} COMMAND${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           Commands:${EOL}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           ${INDENT}${BOLD}fetch${HAIR} [all|repo-name]                    Executes git fetch for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           ${INDENT}${BOLD}pull${HAIR} [all|repo-name]                     Executes git pull for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           ${INDENT}${BOLD}exec${HAIR} [repo-name] [git sub-command]       Executes provided git sub-command for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}[PROJECT ID] info${HAIR}                          Displays project info for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}[PROJECT ID] [${dockerComposeCommand} command]${HAIR}      Executes the ${dockerComposeCommand} command for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID]${HAIR} [${dockerComposeCommand} command]${SPACER}"
    printf "${INDENT}${INDENT}             ${INDENT}${BOLD}help${HAIR}       Outputs the og docker manual.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}regen-hosts${HAIR}   Regenerates the hosts file /etc/hosts.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}update${HAIR}        Updates the og-cli.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}help${HAIR}          Outputs this manual.${EOL}"
    printf "${EOL}"

}

function output_docker_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker${HAIR} COMMAND${SPACER}"
    printf "${INDENT}Commands:${EOL}"
    printf "${INDENT}${INDENT}${BOLD}boot${HAIR}       Regerates hosts files, sets correct permissions for the docker socket, and restarts the docker service.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}init${HAIR}       Initializes a new ${REPO_URI} instance into a directory with the provided PROJECT ID. The PROJECT ID must be lowercase and contain only alphanumeric characters.${SPACER}"
    printf "${INDENT}${INDENT}           Usage: ${BOLD}og docker init${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}destroy${HAIR}    Deletes the project directory, docker images, and docker networks for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}           Usage: ${BOLD}og docker destroy${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}clone${HAIR}      Clones the source project directory, databases, and solr indices for the given source PROJECT ID to the new target PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}           Usage: ${BOLD}og docker clone${HAIR} [SOURCE PROJECT ID] [TARGET PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}build${HAIR}      Builds all of the docker containers for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}           Usage: ${BOLD}og docker build${HAIR} [PROJECT ID]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}[PROJECT ID] install [container]${HAIR}           Executes the installaion script for the given PROJECT ID and container.${SPACER}"
    printf "${INDENT}${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID] install${HAIR} [drupal|django|ckan|ckanapi]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}[PROJECT ID] git [command]${HAIR}                 Runs git tooling for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID] git${HAIR} COMMAND${SPACER}"
    printf "${INDENT}${INDENT}                                           Commands:${EOL}"
    printf "${INDENT}${INDENT}                                           ${INDENT}${BOLD}fetch${HAIR} [all|repo-name]                    Executes git fetch for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}                                           ${INDENT}${BOLD}pull${HAIR} [all|repo-name]                     Executes git pull for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}                                           ${INDENT}${BOLD}exec${HAIR} [repo-name] [git sub-command]       Executes provided git sub-command for the given repo-name.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}[PROJECT ID] info${HAIR}                          Displays project info for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}[PROJECT ID] [${dockerComposeCommand} command]${HAIR}      Executes the ${dockerComposeCommand} command for the given PROJECT ID.${SPACER}"
    printf "${INDENT}${INDENT}                                           Usage: ${BOLD}og docker [PROJECT ID]${HAIR} [${dockerComposeCommand} command]${SPACER}"
    printf "${INDENT}${INDENT}${BOLD}help${HAIR}       Outputs this manual.${EOL}"
    printf "${EOL}"

}

function output_docker_init_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker init${HAIR} [PROJECT ID]${EOL}"
    printf "${EOL}"

}

function output_docker_destroy_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker destroy${HAIR} [PROJECT ID]${EOL}"
    printf "${EOL}"

}

function output_docker_clone_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker clone${HAIR} [SOURCE PROJECT ID] [TARGET PROJECT ID]${EOL}"
    printf "${EOL}"

}

function output_docker_build_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker build${HAIR} [PROJECT ID]${EOL}"
    printf "${EOL}"

}

function output_docker_compose_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker [PROJECT ID]${HAIR} [COMMAND (install|git|info|${dockerComposeCommand} command)]${EOL}"
    printf "${EOL}"

}

function output_docker_install_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker [PROJECT ID] install${HAIR} [drupal|django|ckan|ckanapi]${EOL}"
    printf "${EOL}"

}

function outpur_docker_git_man {

    printf "${EOL}"
    printf "${INDENT}Usage: ${BOLD}og docker [PROJECT ID] git${HAIR} [COMMAND (fetch|pull|exec)] [REPO (all|$(echo ${validRepos} | sed 's/ /|/g'))]${EOL}"
    printf "${EOL}"

}

function does_docker_project_exist {

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ -f "$HOME/.docker-og.d/$1.conf" ]]; then

            echo "true"
            return 0

        fi

    fi

    echo "false"
    return 0

}

function does_project_directory_exist {

    if [[ -d "$(pwd)/$1" ]]; then

        echo "true"
        return 0

    fi

    echo "false"
    return 0

}

function is_project_directory_nested {

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ ! "$(find ${HOME}/.docker-og.d -empty)" ]]; then

            for FILE in ${HOME}/.docker-og.d/*; do

                projectDir="$(head -n 1 $FILE)"
                if [[ "$(pwd)" == *"${projectDir}"* ]]; then

                    echo $projectDir
                    return 0

                fi

            done

        fi

    fi

    echo "false"
    return 0

}

function regenerate_hosts_file {

    if [[ -d "/etc/hosts.d" ]]; then

        if [[ -f "/etc/hosts.d/default.conf" ]]; then

            sudo find /etc/hosts.d -type f | sudo cat $(grep .conf) | sudo tee /etc/hosts >/dev/null

        else

            sudo cp /etc/hosts /etc/hosts.d/default.conf | sed 's/^/    /g'
            sudo chmod a+r /etc/hosts.d/default.conf | sed 's/^/    /g'
            sudo find /etc/hosts.d -type f | sudo cat $(grep .conf) | sudo tee /etc/hosts >/dev/null

        fi

    else

        sudo mkdir /etc/hosts.d | sed 's/^/    /g'
        sudo chmod a+r /etc/hosts.d | sed 's/^/    /g'
        sudo chmod a+x /etc/hosts.d | sed 's/^/    /g'
        sudo cp /etc/hosts /etc/hosts.d/default.conf | sed 's/^/    /g'
        sudo chmod a+r /etc/hosts.d/default.conf | sed 's/^/    /g'
        sudo find /etc/hosts.d -type f | sudo cat $(grep .conf) | sudo tee /etc/hosts >/dev/null

    fi

}

function generate_project_hosts_file {

    regenerate_hosts_file

    if [[ -d "/etc/hosts.d" ]]; then

        if [[ -f "/etc/hosts.d/og.conf" ]]; then

            sudo rm -rf /etc/hosts.d/og.conf | sed 's/^/    /g'

        fi

        sudo touch /etc/hosts.d/og.conf | sed 's/^/    /g'
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Generate project host file /etc/hosts.d/og.conf: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Generate project host file /etc/hosts.d/og.conf: FAIL${NC}${EOL}"
        fi
        sudo chmod a+r /etc/hosts.d/og.conf | sed 's/^/    /g'
        echo "" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "# Hosts generated by the OG CLI for use with Docker" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "127.0.0.1	open.local" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "127.0.0.1	registry.open.local" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "127.0.0.1	portal.open.local" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "127.0.0.1	solr.open.local" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "127.0.0.1	search.open.local" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "# End of OG CLI hosts" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        echo "" | sudo tee -a /etc/hosts.d/og.conf >/dev/null
        sudo find /etc/hosts.d -type f | sudo cat $(grep .conf) | sudo tee /etc/hosts >/dev/null

    fi

}

function generate_project_registry_file {

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ -f "$HOME/.docker-og.d/$1.conf" ]]; then

            rm -rf ~/.docker-og.d/$1.conf

        fi

        touch ~/.docker-og.d/$1.conf
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Generate project registry file $HOME/.docker-og.d/$1.conf: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Generate project registry file $HOME/.docker-og.d/$1.conf: FAIL${NC}${EOL}"
        fi
        echo $(pwd)/$1 > ~/.docker-og.d/$1.conf

    else

        mkdir ~/.docker-og.d
        touch ~/.docker-og.d/$1.conf
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Generate project registry file $HOME/.docker-og.d/$1.conf: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Generate project registry file $HOME/.docker-og.d/$1.conf: FAIL${NC}${EOL}"
        fi
        echo $(pwd)/$1 > ~/.docker-og.d/$1.conf

    fi

}

function delete_project_registry_file {

    if [[ -f "$HOME/.docker-og.d/$1.conf" ]]; then

        rm -rf ~/.docker-og.d/$1.conf
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Delete project registry file $HOME/.docker-og.d/$1.conf: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Delete project registry file $HOME/.docker-og.d/$1.conf: FAIL${NC}${EOL}"
        fi

    fi

}

function get_working_directory_from_project_id {

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ -f "$HOME/.docker-og.d/$1.conf" ]]; then

            echo "$(head -n 1 $HOME/.docker-og.d/$1.conf)"
            return 0

        fi

    fi

    echo "false"
    return 0

}

function initialize_port_pool {

    if [[ ! -d "$HOME/.docker-og.pools/ports" ]]; then

        mkdir -p ~/.docker-og.pools/ports
        touch ~/.docker-og.pools/ports/{57000..57999}.port

    fi

}

function rent_port_number {

    initialize_port_pool

    portNumber=""

    if [[ -f "$(pwd)/$1/.env" ]]; then

        portNumber=$(ls ~/.docker-og.pools/ports | head -1 | sed -e "s/\.port$//")
        echo -e "PORT=${portNumber}\n" >> $(pwd)/$1/.env

        if [[ $? -eq 0 ]]; then

            printf "${Green}${INDENT}Rent port number ${portNumber} for proxy: OK${NC}${EOL}"
            rm $(ls ~/.docker-og.pools/ports/* | head -1)
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Remove port number ${portNumber} from pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Remove port number ${portNumber} from pool: FAIL${NC}${EOL}"
            fi

        else

            printf "${Red}${INDENT}Rent port number for proxy: FAIL${NC}${EOL}"

        fi

        portNumber=$(ls ~/.docker-og.pools/ports | head -1 | sed -e "s/\.port$//")
        echo -e "DBPORT=${portNumber}\n" >> $(pwd)/$1/.env

        if [[ $? -eq 0 ]]; then

            printf "${Green}${INDENT}Rent port number ${portNumber} for postgres: OK${NC}${EOL}"
            rm $(ls ~/.docker-og.pools/ports/* | head -1)
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Remove port number ${portNumber} from pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Remove port number ${portNumber} from pool: FAIL${NC}${EOL}"
            fi

        else

            printf "${Red}${INDENT}Rent port number for postgres: FAIL${NC}${EOL}"

        fi
        
    fi

}

function release_port_number {

    initialize_port_pool

    if [[ -f "$1/.env" ]]; then

        source $1/.env

        if [[ ! -f "~/.docker-og.pools/ports/$PORT.port" ]]; then

            touch ~/.docker-og.pools/ports/$PORT.port
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Release port number ${PORT} into pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Release port number ${PORT} into pool: FAIL${NC}${EOL}"
            fi

        fi

        if [[ ! -f "~/.docker-og.pools/ports/$DBPORT.port" ]]; then

            touch ~/.docker-og.pools/ports/$DBPORT.port
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Release port number ${DBPORT} into pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Release port number ${DBPORT} into pool: FAIL${NC}${EOL}"
            fi

        fi

    fi

}

function initialize_octet_pool {

    if [[ ! -d "$HOME/.docker-og.pools/octets" ]]; then

        mkdir -p ~/.docker-og.pools/octets
        touch ~/.docker-og.pools/octets/{1..254}.octet

    fi

}

function rent_ip_octet {

    initialize_octet_pool

    octet=""

    if [[ -f "$(pwd)/$1/.env" ]]; then

        octet=$(ls ~/.docker-og.pools/octets | head -1 | sed -e "s/\.octet$//")
        echo -e "OCTET=${octet}\n" >> $(pwd)/$1/.env

        if [[ $? -eq 0 ]]; then

            printf "${Green}${INDENT}Rent port number ${octet} for proxy: OK${NC}${EOL}"
            rm $(ls ~/.docker-og.pools/octets/* | head -1)
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Remove octet ${octet} from pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Remove octet ${octet} from pool: FAIL${NC}${EOL}"
            fi

        else

            printf "${Red}${INDENT}Rent octet for docker network: FAIL${NC}${EOL}"

        fi
        
    fi

}

function release_ip_octet {

    initialize_octet_pool

    if [[ -f "$1/.env" ]]; then

        source $1/.env

        if [[ ! -f "~/.docker-og.pools/octets/$OCTET.octet" ]]; then

            touch ~/.docker-og.pools/octets/$OCTET.octet
            if [[ $? -eq 0 ]]; then
                printf "${Green}${INDENT}Release octet ${OCTET} into pool: OK${NC}${EOL}"
            else
                printf "${Red}${INDENT}Release octet ${OCTET} into pool: FAIL${NC}${EOL}"
            fi

        fi

    fi

}

function does_local_git_repo_exist {

    baseDir=$1
    repo=$2
    ckanInstall="registry"

    if [[ "$3" ]]; then

        ckanInstall=$3

    fi

    case $repo in

        ("opengov")
            if [[ -d $baseDir/drupal/html ]]; then
                echo "$baseDir/drupal"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("og")
            if [[ -d $baseDir/drupal/html/profiles/og/modules ]]; then
                echo "$baseDir/drupal/html/profiles/og"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("gcweb_bootstrap")
            if [[ -d $baseDir/drupal/html/themes/custom/gcweb/templates ]]; then
                echo "$baseDir/drupal/html/themes/custom/gcweb"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ogc_search")
            if [[ -d $baseDir/django/src/ogc-search/ogc_search ]]; then
                echo "$baseDir/django/src/ogc-search"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckan")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckan/ckan ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckan"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanapi")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanapi/ckanapi ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanapi"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-canada")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-canada/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-canada"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-cloudstorage")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-cloudstorage/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-cloudstorage"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-dcat")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-dcat/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-dcat"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-extendedactivity")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-extendedactivity/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-extendedactivity"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-extractor")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-extractor/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-extractor"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-fluent")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-fluent/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-fluent"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-recombinant")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-recombinant/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-recombinant"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-scheming")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-scheming/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-scheming"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-security")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-security/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-security"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-validation")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-validation/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-validation"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-xloader")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-xloader/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-xloader"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckantoolkit")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckantoolkit/ckantoolkit ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckantoolkit"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("goodtables")
            if [[ -d $baseDir/ckan/$ckanInstall/src/goodtables/goodtables ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/goodtables"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

        ("ckanext-wet-boew")
            if [[ -d $baseDir/ckan/$ckanInstall/src/ckanext-wet-boew/ckanext ]]; then
                echo "$baseDir/ckan/$ckanInstall/src/ckanext-wet-boew"
                return 0
            else
                echo "false"
                return 0
            fi
            ;;

    esac

    echo "false"
    return 0

}

function execute_git_command {

    dir=$1
    repo=$2
    command=$3

    if [[ $repo == "all" ]]; then

        repoArray=($validRepos)
        gitCommandCount=0
        for i in "${repoArray[@]}"
            do
            :
                if [[ $i == "opengov" || $i == "og" || $i == "gcweb_bootstrap" || $i == "ogc_search" ]]; then
                    if [[ $(does_local_git_repo_exist $dir $i) != "false" ]]; then
                        let gitCommandCount++
                        localRepo="$(does_local_git_repo_exist $dir $i)"
                        cd $localRepo
                        localBranch="$(git rev-parse --abbrev-ref HEAD)"
                        if [[ $command == "fetch" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Fetching ${i} (${localBranch})...${NC}${EOL}"
                            git fetch
                            if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                                git status
                            else
                                printf "${Cyan}${INDENT}No new commits found for ${i} (${localBranch})...${NC}${EOL}"
                            fi
                        elif [[ $command == "pull" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Pulling ${i} (${localBranch})...${NC}${EOL}"
                            git pull
                        fi
                    fi
                else
                    if [[ $(does_local_git_repo_exist $dir $i registry) != "false" ]]; then
                        let gitCommandCount++
                        localRepo="$(does_local_git_repo_exist $dir $i registry)"
                        cd $localRepo
                        localBranch="$(git rev-parse --abbrev-ref HEAD)"
                        if [[ $command == "fetch" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Fetching ${i} (${localBranch}) (registry)...${NC}${EOL}"
                            git fetch
                            if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                                git status
                            else
                                printf "${Cyan}${INDENT}No new commits found for ${i} (${localBranch}) (registry)...${NC}${EOL}"
                            fi
                        elif [[ $command == "pull" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Pulling ${i} (${localBranch}) (registry)...${NC}${EOL}"
                            git pull
                        fi
                    fi
                    if [[ $(does_local_git_repo_exist $dir $i portal) != "false" ]]; then
                        let gitCommandCount++
                        localRepo="$(does_local_git_repo_exist $dir $i portal)"
                        cd $localRepo
                        localBranch="$(git rev-parse --abbrev-ref HEAD)"
                        if [[ $command == "fetch" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Fetching ${i} (${localBranch}) (portal)...${NC}${EOL}"
                            git fetch
                            if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                                git status
                            else
                                printf "${Cyan}${INDENT}No new commits found for ${i} (${localBranch}) (portal)...${NC}${EOL}"
                            fi
                        elif [[ $command == "pull" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Pulling ${i} (${localBranch}) (portal)...${NC}${EOL}"
                            git pull
                        fi
                    fi
                fi
            done

        if [[ $gitCommandCount == 0 ]]; then

            printf "${EOL}"
            printf "${Red}${INDENT}No local repositories were found for the project ${BOLD}${projectID}${HAIR}${Red}. Have you run the installation for any applications?${HAIR}${NC}${EOL}"

        fi

    else

        if [[ $repo == "opengov" || $repo == "og" || $repo == "gcweb_bootstrap" || $repo == "ogc_search" ]]; then

            if [[ $(does_local_git_repo_exist $dir $repo) != "false" ]]; then

                localRepo="$(does_local_git_repo_exist $dir $repo)"
                cd $localRepo
                localBranch="$(git rev-parse --abbrev-ref HEAD)"

                if [[ $command == "fetch" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Fetching ${repo} (${localBranch})...${NC}${EOL}"
                    git fetch
                    if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                        git status
                    else
                        printf "${Cyan}${INDENT}No new commits found for ${repo} (${localBranch})...${NC}${EOL}"
                    fi

                elif [[ $command == "pull" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Pulling ${repo} (${localBranch})...${NC}${EOL}"
                    git pull

                elif [[ $command == "exec" ]]; then

                    gitCommand="${@:4}"
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Executing git ${gitCommand} for ${repo} (${localBranch})...${NC}${EOL}"
                    git $gitCommand

                fi

            else

                printf "${EOL}"
                printf "${Red}${INDENT}${BOLD}${repo}${HAIR}${Red} repository does not exist locally for the project ${BOLD}${projectID}${HAIR}${Red}. Have you run the installation for that application?${HAIR}${NC}${EOL}"

            fi

        else

            if [[ $(does_local_git_repo_exist $dir $repo registry) != "false" ]]; then

                localRepo="$(does_local_git_repo_exist $dir $repo registry)"
                cd $localRepo
                localBranch="$(git rev-parse --abbrev-ref HEAD)"

                if [[ $command == "fetch" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Fetching ${repo} (${localBranch}) (registry)...${NC}${EOL}"
                    git fetch
                    if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                        git status
                    else
                        printf "${Cyan}${INDENT}No new commits found for ${repo} (${localBranch}) (registry)...${NC}${EOL}"
                    fi

                elif [[ $command == "pull" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Pulling ${repo} (${localBranch}) (registry)...${NC}${EOL}"
                    git pull

                elif [[ $command == "exec" ]]; then

                    gitCommand="${@:4}"
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Executing git ${gitCommand} for ${repo} (${localBranch}) (registry)...${NC}${EOL}"
                    git $gitCommand

                fi

            else

                printf "${EOL}"
                printf "${Red}${INDENT}${BOLD}${repo}${HAIR}${Red} repository does not exist locally for the project ${BOLD}${projectID}${HAIR}${Red}. Have you run the installation for that application? (extra info: not found in CKAN registry)${HAIR}${NC}${EOL}"

            fi

            if [[ $(does_local_git_repo_exist $dir $repo portal) != "false" ]]; then

                localRepo="$(does_local_git_repo_exist $dir $repo portal)"
                cd $localRepo
                localBranch="$(git rev-parse --abbrev-ref HEAD)"

                if [[ $command == "fetch" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Fetching ${repo} (${localBranch}) (portal)...${NC}${EOL}"
                    git fetch
                    if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then
                        git status
                    else
                        printf "${Cyan}${INDENT}No new commits found for ${repo} (${localBranch}) (portal)...${NC}${EOL}"
                    fi

                elif [[ $command == "pull" ]]; then

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Pulling ${repo} (${localBranch}) (portal)...${NC}${EOL}"
                    git pull

                elif [[ $command == "exec" ]]; then

                    gitCommand="${@:4}"
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Executing git ${gitCommand} for ${repo} (${localBranch}) (portal)...${NC}${EOL}"
                    git $gitCommand

                fi

            else

                printf "${EOL}"
                printf "${Red}${INDENT}${BOLD}${repo}${HAIR}${Red} repository does not exist locally for the project ${BOLD}${projectID}${HAIR}${Red}. Have you run the installation for that application? (extra info: not found in CKAN portal)${HAIR}${NC}${EOL}"

            fi

        fi

    fi

    printf "${EOL}"

}

function git_command {

    errorMessage="false"

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ -f "$HOME/.docker-og.d/$2.conf" ]]; then

            projectID=$2
            dir="$(head -n 1 $HOME/.docker-og.d/$2.conf)"

            if [[ $4 ]]; then

                gitSubCommand=$4
                repo=$5

                if [[ $repo ]]; then

                    if [[ $gitSubCommand == "fetch" ]]; then

                        errorMessage="true"

                        if [[ "$validRepos all" == *"$repo"* ]]; then

                            errorMessage="false"
                            execute_git_command $dir $repo "fetch"

                        fi

                    elif [[ $gitSubCommand == "pull" ]]; then

                        errorMessage="true"

                        if [[ "$validRepos all" == *"$repo"* ]]; then

                            errorMessage="false"
                            execute_git_command $dir $repo "pull"

                        fi

                    elif [[ $gitSubCommand == "exec" ]]; then

                        errorMessage="true"

                        if [[ "$validRepos" == *"$repo"* ]]; then

                            errorMessage="false"
                            execute_git_command $dir $repo "exec" "${@:6}"

                        fi

                    else

                        printf "${EOL}"
                        printf "${Red}${INDENT}${BOLD}${gitSubCommand}${HAIR}${Red} is not a recognized git command in og-cli. For more advanced git usage, access the local repository directly.${HAIR}${NC}${SPACER}"

                    fi

                else

                    printf "${EOL}"
                    printf "${Yellow}${INDENT}Please supply a REPO${NC}${EOL}"
                    outpur_docker_git_man

                fi

            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}Please supply a COMMAND${NC}${EOL}"
                outpur_docker_git_man

            fi

        fi

    fi

    if [[ $errorMessage != "false" ]]; then

        printf "${EOL}"
        printf "${Red}${INDENT}${BOLD}${repo}${HAIR}${Red} is not a recognized git repository in the og applications.${HAIR}${NC}${SPACER}"

    fi

}

function project_info {

    if [[ -d "$HOME/.docker-og.d" ]]; then

        if [[ -f "$HOME/.docker-og.d/$1.conf" ]]; then

            dir="$(head -n 1 $HOME/.docker-og.d/$1.conf)"

            if [[ -f "$dir/.env" ]]; then

                source $dir/.env

                drupalProjectURI="$(echo '\e]8;;http://open.local:${PORT}\e\\open.local:${PORT}\e]8;;\e\\' | sed -e "s/\${PORT}/${PORT}/g")"
                djangoProjectURI="$(echo '\e]8;;http://search.open.local:${PORT}\e\\search.open.local:${PORT}\e]8;;\e\\' | sed -e "s/\${PORT}/${PORT}/g")"
                ckanProjectURI="$(echo '\e]8;;http://registry.open.local:${PORT}\e\\registry.open.local:${PORT}\e]8;;\e\\' | sed -e "s/\${PORT}/${PORT}/g")"
                solrProjectURI="$(echo '\e]8;;http://solr.open.local:${PORT}\e\\solr.open.local:${PORT}\e]8;;\e\\' | sed -e "s/\${PORT}/${PORT}/g")"

                databaseBaseURI="homestead:secret@open.local:${DBPORT}/"

                printf "${EOL}"
                printf "${INDENT}Project ID:           ${BOLD}${PROJECT_ID}${HAIR}${SPACER}"
                printf "${INDENT}Working Directory:    ${BOLD}${dir}${HAIR}${SPACER}"
                printf "${INDENT}Docker Network:       ${BOLD}172.25.${OCTET}.0/24${HAIR}${SPACER}"
                printf "${INDENT}Web Port:             ${BOLD}${PORT}${HAIR}${SPACER}"
                printf "${INDENT}Database Port:        ${BOLD}${DBPORT}${HAIR}${SPACER}"
                printf "${INDENT}Web Addresses:${EOL}"
                printf "${INDENT}${INDENT}Drupal:           ${BOLD}${drupalProjectURI}${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Registry:         ${BOLD}${ckanProjectURI}${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Search:           ${BOLD}${djangoProjectURI}${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Solr:             ${BOLD}${solrProjectURI}${HAIR}${EOL}"
                printf "${EOL}"
                printf "${INDENT}Database Addresses:${EOL}"
                printf "${INDENT}${INDENT}Drupal:           ${BOLD}${databaseBaseURI}og_drupal_local${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Drupal Test:      ${BOLD}${databaseBaseURI}og_drupal_local__test${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Portal:           ${BOLD}${databaseBaseURI}og_ckan_portal_local${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Portal Test:      ${BOLD}${databaseBaseURI}og_ckan_portal_local__test${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Portal DS:        ${BOLD}${databaseBaseURI}og_ckan_portal_ds_local${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Portal DS Test:   ${BOLD}${databaseBaseURI}og_ckan_portal_ds_local__test${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Registry:         ${BOLD}${databaseBaseURI}og_ckan_registry_local${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Registry Test:    ${BOLD}${databaseBaseURI}og_ckan_registry_local__test${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Registry DS:      ${BOLD}${databaseBaseURI}og_ckan_registry_ds_local${HAIR}${EOL}"
                printf "${INDENT}${INDENT}Registry DS Test: ${BOLD}${databaseBaseURI}og_ckan_registry_ds_local__test${HAIR}${EOL}"
                printf "${EOL}"

            fi

        fi

    fi

}

function docker_init_command {

    isCloning='false'

    if [[ $1 == 'clone' ]]; then

        isCloning='true'

    fi

    if [[ $3 ]]; then

        if [[ $3 == "default" ]]; then

            printf "${EOL}"
            printf "${Red}${INDENT}Project ID ${ITALIC}${BOLD}$3${HAIR}${Red} is a reserved ID. Abandoning docker project creation.${NC}${SPACER}"
            return 0

        fi

        if [[ ! -z "${3//[_[:digit:][:lower:]]}" && ! -z "${3//[-[:digit:][:lower:]]}" ]]; then

            printf "${EOL}"
            printf "${Red}${INDENT}Provided ID ${ITALIC}${BOLD}$3${HAIR}${Red} illegal. Project IDs must be lowercase and contain only alphanumeric characters. Abandoning docker project creation.${NC}${SPACER}"
            return 0

        fi

        if [[ $(does_docker_project_exist $3) == "false" ]]; then

            if [[ $(does_project_directory_exist $3) == "false" ]]; then

                if [[ $(is_project_directory_nested $3) == "false" ]]; then

                    projectID=$3
                    confirmProjectCreation='false'

                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Are you sure you want to create a new Docker OG project at ${ITALIC}${BOLD}$(pwd)/${projectID}${HAIR}${Cyan} with the ID of ${ITALIC}${BOLD}${projectID}${HAIR}${Cyan}?${NC}${EOL}"
                    read -r -p $'\033[0;36m    [y/N]: \033[0;0m' response

                    if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then

                        confirmProjectCreation='true'

                    fi

                    if [[ $confirmProjectCreation == "true" ]]; then

                        # create hosts file for the project ID
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Generating host file ${ITALIC}${BOLD}/etc/hosts.d/og.conf${HAIR}${Cyan}. Maybe prompt for admin password...${NC}${EOL}"
                        generate_project_hosts_file

                        # create directory for the project ID
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Creating project directory ${ITALIC}${BOLD}$(pwd)/${projectID}${HAIR}${Cyan} for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        mkdir $(pwd)/$projectID
                        if [[ $? -eq 0 ]]; then
                            printf "${Green}${INDENT}Create project directory $(pwd)/${projectID}: OK${NC}${EOL}"
                        else
                            printf "${Red}${INDENT}Create project directory $(pwd)/${projectID}: FAIL${NC}${EOL}"
                        fi

                        # add absolute directory path to registry file for the project ID
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Creating project registry file ${ITALIC}${BOLD}~/.docker-og.d/${projectID}.conf${HAIR}${Cyan} for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        generate_project_registry_file $3

                        # pull docker-og repo into project directory
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Cloning ${REPO_URI} into project directory ${ITALIC}${BOLD}$(pwd)/${projectID}${HAIR}${Cyan} for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        git clone https://github.com/open-data/docker-og.git $(pwd)/$projectID 2>&1 | sed 's/^/    /g'
                        if [[ $? -eq 0 ]]; then
                            printf "${Green}${INDENT}Clone ${REPO_URI} into $(pwd)/${projectID}: OK${NC}${EOL}"
                        else
                            printf "${Red}${INDENT}Clone ${REPO_URI} into $(pwd)/${projectID}: FAIL${NC}${EOL}"
                        fi
                        
                        # create .env file and put project ID into it
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Creating ${ITALIC}${BOLD}.env${HAIR}${Cyan} file for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        touch $(pwd)/$projectID/.env
                        if [[ $? -eq 0 ]]; then
                            printf "${Green}${INDENT}Create project environment file $(pwd)/$projectID/.env: OK${NC}${EOL}"
                        else
                            printf "${Red}${INDENT}Create project environment file $(pwd)/$projectID/.env: FAIL${NC}${EOL}"
                        fi
                        echo -e "PROJECT_ID=$projectID\nUSER_ID=$(id -u)\nGROUP_ID=$(id -g)\n" > $(pwd)/$projectID/.env

                        # renting some port numbers from the pool
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Renting port numbers for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        rent_port_number $3

                        # renting an ip octet from the pool
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Renting ip octet for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        rent_ip_octet $3

                        # create .env.conf file and put project ID into it
                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Creating ${ITALIC}${BOLD}.env.conf${HAIR}${Cyan} nginx file for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                        touch $(pwd)/$projectID/docker/config/nginx/conf/.env.conf
                        if [[ $? -eq 0 ]]; then
                            printf "${Green}${INDENT}Create project environment file $(pwd)/$projectID/docker/config/nginx/conf/.env.conf: OK${NC}${EOL}"
                        else
                            printf "${Red}${INDENT}Create project environment file $(pwd)/$projectID/docker/config/nginx/conf/.env.conf: FAIL${NC}${EOL}"
                        fi
                        echo "set \$projectID \"$projectID\";" > $(pwd)/$projectID/docker/config/nginx/conf/.env.conf
                        
                        # run the pre-build.sh script
                        if [[ -f "$(pwd)/$projectID/pre-build.sh" ]]; then
                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Running ${ITALIC}${BOLD}pre-build.sh${HAIR}${Cyan} script for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                            chmod 775 $(pwd)/$projectID/pre-build.sh
                            $(pwd)/$projectID/pre-build.sh $projectID no-interaction $(pwd)/$projectID
                        fi

                        # add execution to installation script
                        if [[ -f "$(pwd)/$projectID/install-local.sh" ]]; then
                            chmod 775 $(pwd)/$projectID/install-local.sh
                        fi
                        
                        printf "${Cyan}${INDENT}Project ${ITALIC}${BOLD}$3${HAIR}${Cyan} successfully initiated in the directory $(pwd)/$projectID: ${NC}${EOL}"

                        if [[ $isCloning == 'false' ]]; then

                            confirmBuildContainers='false'

                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Did you want to build the docker containers for project ${ITALIC}${BOLD}$projectID${HAIR}${Cyan}?${NC}${EOL}"
                            read -r -p $'\033[0;36m    [y/N]: \033[0;0m' response

                            if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then

                                confirmBuildContainers='true'

                            fi

                            if [[ $confirmBuildContainers == "true" ]]; then

                                og docker build $projectID

                            fi

                            printf "${Cyan}${INDENT}Run ${ITALIC}${BOLD}og docker $projectID install [drupal|django|ckan]${HAIR}${Cyan} to install the apps into their containers.${NC}${EOL}"
                            printf "${EOL}"

                        fi

                    else
                        
                        printf "${EOL}"
                        printf "${Yellow}${INDENT}Abandoning docker project creation with ID: ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD}${NC}${SPACER}"

                    fi

                else
                        
                    nestedDir=$(is_project_directory_nested $3)
                    printf "${EOL}"
                    printf "${Yellow}${INDENT}Nested projects are not supported. There is already a project in the directory tree: ${ITALIC}${BOLD}$nestedDir${HAIR}${Yellow}${BOLD}${NC}${SPACER}"

                fi
        
            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}Project directory ${ITALIC}${BOLD}$(pwd)/$3${HAIR}${Yellow}${BOLD} already exist.${NC}${SPACER}"

            fi

        else

            printf "${EOL}"
            printf "${Yellow}${INDENT}Docker project with ID ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} already exist.${NC}${SPACER}"

        fi

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}Please supply a PROJECT ID${NC}${EOL}"
        output_docker_init_man

    fi

}

function docker_destroy_command {

    if [[ $3 ]]; then

        if [[ $(does_docker_project_exist $3) == "true"  ]]; then

            if [[ $(get_working_directory_from_project_id $3) != "false"  ]]; then

                projectID=$3
                projectDir="$(head -n 1 $HOME/.docker-og.d/$3.conf)"
                confirmProjectDeletion='false'

                printf "${EOL}"
                printf "${Cyan}${INDENT}Are you sure you want to delete the Docker OG project at ${ITALIC}${BOLD}${projectDir}${HAIR}${Cyan} with the ID of ${ITALIC}${BOLD}${projectID}${HAIR}${Cyan}?${NC}${EOL}"
                read -r -p $'\033[0;36m    [y/N]: \033[0;0m' response

                if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then

                    confirmProjectDeletion='true'

                fi

                if [[ $confirmProjectDeletion == "true" ]]; then

                    # delete docker images for the project ID
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Removing docker images for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                    docker image prune --force --filter "label=projectID=$projectID" | sed 's/^/    /g'
                    if [[ $? -eq 0 ]]; then
                        printf "${Green}${INDENT}Delete docker images labeled with 'projectID=$projectID': OK${NC}${EOL}"
                    else
                        printf "${Red}${INDENT}Delete docker images labeled with 'projectID=$projectID': FAIL${NC}${EOL}"
                    fi

                    # release port numbers back into pool
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Releasing port numbers back into the pool for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                    release_port_number $projectDir

                    # release octet back into pool
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Releasing ip octet back into the pool for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                    release_ip_octet $projectDir

                    # delete directory for the project ID
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Removing project directory ${ITALIC}${BOLD}$projectDir${HAIR}${Cyan} for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                    rm -rf $projectDir
                    if [[ $? -eq 0 ]]; then
                        printf "${Green}${INDENT}Delete project directory $projectDir: OK${NC}${EOL}"
                    else
                        printf "${Red}${INDENT}Delete project directory $projectDir: FAIL${NC}${EOL}"
                    fi

                    # delete registry file for the project ID
                    printf "${EOL}"
                    printf "${Cyan}${INDENT}Removing project registry file ${ITALIC}${BOLD}~/.docker-og.d/${projectID}.conf${HAIR}${Cyan} for project ID: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                    delete_project_registry_file $3
                    printf "${EOL}"

                else

                    printf "${EOL}"
                    printf "${Yellow}${INDENT}Abandoning docker project deletion with ID: ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD}${NC}${SPACER}"

                fi

            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}Project directory for ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

            fi

        else

            printf "${EOL}"
            printf "${Yellow}${INDENT}Docker project with ID ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

        fi

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}Please supply a PROJECT ID${NC}${EOL}"
        output_docker_destroy_man

    fi

}

function docker_clone_command {

    if [[ $3 ]]; then

        if [[ $(does_docker_project_exist $3) == "true"  ]]; then

            if [[ $(get_working_directory_from_project_id $3) != "false"  ]]; then

                if [[ $(does_docker_project_exist $4) == "true"  ]]; then

                    if [[ $(get_working_directory_from_project_id $4) != "false"  ]]; then

                        sourceProjectID=$3
                        sourceProjectDir="$(head -n 1 $HOME/.docker-og.d/$3.conf)"
                        targetProjectID=$4
                        targetProjectDir="$(head -n 1 $HOME/.docker-og.d/$4.conf)"
                        confirmProjectCloning='false'

                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Are you sure you want to overwrite the Docker OG project at ${ITALIC}${BOLD}${targetProjectDir}${HAIR}${Cyan} with the Docker OG project at ${ITALIC}${BOLD}${sourceProjectDir}${HAIR}${Cyan}? [${sourceProjectID} --> ${targetProjectID}]${NC}${EOL}"
                        read -r -p $'\033[0;36m    [y/N]: \033[0;0m' response

                        if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then

                            confirmProjectCloning='true'

                        fi

                        if [[ $confirmProjectCloning == "true" ]]; then

                            printf "${EOL}"
                            printf "${Cyan}${INDENT}Copying ${ITALIC}${BOLD}${sourceProjectID}${HAIR}${Cyan} to ${ITALIC}${BOLD}${targetProjectID}${HAIR}${Cyan}...${NC}${EOL}"

                            cd $sourceProjectDir
                            rsync --progress --archive --verbose --delete --recursive --perms --exclude=/.env --exclude=/_config --exclude=/docker --exclude=/backup/local_configs . $targetProjectDir | sed 's/^/    /g'

                        else

                            printf "${EOL}"
                            printf "${Yellow}${INDENT}Abandoning docker project cloning: ${ITALIC}${BOLD}[${sourceProjectID} --> ${targetProjectID}]${HAIR}${Yellow}${BOLD}${NC}${SPACER}"

                        fi

                    else

                        printf "${EOL}"
                        printf "${Yellow}${INDENT}Project directory for ${ITALIC}${BOLD}$4${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

                    fi

                else

                    printf "${EOL}"
                    printf "${INDENT}${Cyan}Project ${ITALIC}${BOLD}$4${HAIR}${Cyan} does not exist...creating new Docker OG project.${NC}${EOL}"
                    docker_init_command "${@:2}"

                    sourceProjectID=$3
                    sourceProjectDir="$(head -n 1 $HOME/.docker-og.d/$3.conf)"

                    if [[ -f "$HOME/.docker-og.d/$4.conf" ]]; then

                        targetProjectID=$4
                        targetProjectDir="$(head -n 1 $HOME/.docker-og.d/$4.conf)"

                        printf "${EOL}"
                        printf "${Cyan}${INDENT}Copying ${ITALIC}${BOLD}${sourceProjectID}${HAIR}${Cyan} to ${ITALIC}${BOLD}${targetProjectID}${HAIR}${Cyan}...${NC}${EOL}"

                        cd $sourceProjectDir
                        rsync --progress --archive --verbose --delete --recursive --perms --exclude=/.env --exclude=/_config --exclude=/docker --exclude=/backup/local_configs . $targetProjectDir | sed 's/^/    /g'

                    fi

                fi

            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}Project directory for ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

            fi

        else

            printf "${EOL}"
            printf "${Yellow}${INDENT}Docker project with ID ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

        fi

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}Please supply a PROJECT ID${NC}${EOL}"
        output_docker_clone_man

    fi

}

function docker_build_command {

    if [[ $3 ]]; then

        if [[ $(does_docker_project_exist $3) == "true"  ]]; then

            if [[ $(get_working_directory_from_project_id $3) != "false"  ]]; then

                projectID=$3
                projectDir="$(head -n 1 $HOME/.docker-og.d/$3.conf)"
                printf "${EOL}"
                printf "${Cyan}${INDENT}Running build for docker project: ${ITALIC}${BOLD}$3${HAIR}${Cyan}${NC}${EOL}"
                cd $projectDir
                $dockerComposeCommand build | sed 's/^/    /g'
                printf "${Cyan}${INDENT}Build attempt for docker project: ${ITALIC}${BOLD}$3${HAIR}${Cyan} complete.${NC}${EOL}"
                printf "${EOL}"

            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}Project directory for ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

            fi

        else

            printf "${EOL}"
            printf "${Yellow}${INDENT}Docker project with ID ${ITALIC}${BOLD}$3${HAIR}${Yellow}${BOLD} does not exist.${NC}${SPACER}"

        fi

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}Please supply a PROJECT ID${NC}${EOL}"
        output_docker_build_man

    fi

}

function attempt_docker_compose_commands {

    if [[ $2 ]]; then
        
        if [[ $(does_docker_project_exist $2) == "true"  ]]; then

            if [[ $(get_working_directory_from_project_id $2) != "false"  ]]; then

                if [[ $3 ]]; then

                    if [[ $3 == "install" ]]; then

                        validAppRole='false'

                        if [[ $4 == "drupal" ]]; then validAppRole='true'; fi
                        if [[ $4 == "django" ]]; then validAppRole='true'; fi
                        if [[ $4 == "ckan" ]]; then validAppRole='true'; fi
                        if [[ $4 == "ckanapi" ]]; then validAppRole='true'; fi

                        if [[ $validAppRole == "false" ]]; then

                            printf "${EOL}"
                            printf "${Yellow}${INDENT}CONTAINER $4 invalid for app installation${NC}${EOL}"
                            output_docker_install_man

                        else

                            projectID=$2
                            projectDir="$(head -n 1 $HOME/.docker-og.d/$2.conf)"
                            appRole=$4
                            printf "${Cyan}Running ${ITALIC}${BOLD}$appRole installation${HAIR}${Cyan} for docker project: ${ITALIC}${BOLD}$2${HAIR}${Cyan}${NC}${EOL}"
                            cd $projectDir
                            $dockerComposeCommand up -d $appRole
                            if [[ $? -eq 0 ]]; then
                                $dockerComposeCommand exec $appRole bash -c "./install.sh"
                            else
                                printf "${Red}${INDENT}Something went wrong bringing up the ${ITALIC}${BOLD}$appRole container${HAIR}${Red} for the project: ${ITALIC}${BOLD}$projectID${HAIR}${Red}. Exiting installation...${NC}${EOL}"
                            fi

                        fi

                    elif [[ $3 == "info" ]]; then

                        project_info $2

                    elif [[ $3 == "git" ]]; then

                        git_command "${@}"

                    else

                        projectID=$2
                        projectDir="$(head -n 1 $HOME/.docker-og.d/$2.conf)"
                        printf "${Cyan}Running ${dockerComposeCommand} command ${ITALIC}${BOLD}$3${HAIR}${Cyan} for docker project: ${ITALIC}${BOLD}$2${HAIR}${Cyan}${NC}${EOL}"
                        cd $projectDir
                        $dockerComposeCommand "${@:3}"

                    fi

                else 

                    printf "${EOL}"
                    printf "${Yellow}${INDENT}Missing COMMAND${NC}${EOL}"
                    output_docker_compose_man

                fi

            else

                if [[ $3 ]]; then

                    printf "${EOL}"
                    printf "${Yellow}${INDENT}COMMAND ${ITALIC}${BOLD}$2${HAIR}${Yellow}${BOLD} not found (project may not exist)${NC}${EOL}"
                    output_docker_man

                else

                    printf "${EOL}"
                    printf "${Yellow}${INDENT}COMMAND ${ITALIC}${BOLD}$2${HAIR}${Yellow}${BOLD} not found${NC}${EOL}"
                    output_docker_man

                fi

            fi

        else

            if [[ $3 ]]; then

                printf "${EOL}"
                printf "${Yellow}${INDENT}COMMAND ${ITALIC}${BOLD}$2${HAIR}${Yellow}${BOLD} not found (project may not exist)${NC}${EOL}"
                output_docker_man

            else

                printf "${EOL}"
                printf "${Yellow}${INDENT}COMMAND ${ITALIC}${BOLD}$2${HAIR}${Yellow}${BOLD} not found${NC}${EOL}"
                output_docker_man

            fi

        fi

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}Missing COMMAND${NC}${EOL}"
        output_docker_man

    fi

}

function boot_docker_command {

        printf "${EOL}"
        printf "${Cyan}${INDENT}Setting correct permissions for docker socket. Maybe prompt for admin password...${NC}${EOL}"
        sudo chmod 666 /var/run/docker.sock
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Set permissions for /var/run/docker.sock: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Set permissions for /var/run/docker.sock: FAIL${NC}${EOL}"
        fi
        printf "${Cyan}${INDENT}Generating host file ${ITALIC}${BOLD}/etc/hosts.d/og.conf${HAIR}${Cyan}. Maybe prompt for admin password...${NC}${EOL}"
        generate_project_hosts_file
        printf "${Cyan}${INDENT}Restarting docker service. Maybe prompt for admin password...${NC}${EOL}"
        sudo service docker restart
        if [[ $? -eq 0 ]]; then
            printf "${Green}${INDENT}Restart docker service: OK${NC}${EOL}"
        else
            printf "${Red}${INDENT}Restart docker service: FAIL${NC}${EOL}"
        fi
        printf "${EOL}"

}

function docker_command  {

    if [[ -x "$(command -v docker)" ]]; then

        # Gets the correct docker compose command (docker compose being the newest and docker-compose being older)
        if [[ "$(docker --help | grep compose)" ]]; then

            dockerComposeCommand='docker compose'

        elif [[ -x "$(command -v docker-compose)" ]]; then

            dockerComposeCommand='docker-compose'

        else

            dockerComposeCommand='false'

        fi

        if [[ dockerComposeCommand != "false" ]]; then

            if [[ -x "$(command -v git)" ]]; then

                if [[ "$(pgrep docker | head -1)" ]]; then

                    if [[ $2 ]]; then

                        if [[ "$(stat -L -c '%a' /var/run/docker.sock)" != "666" ]]; then

                            printf "${Cyan}${INDENT}Setting correct permissions for docker socket. Maybe prompt for admin password...${NC}${EOL}"
                            sudo chmod 666 /var/run/docker.sock

                        fi

                        if [[ $2 == "init" ]]; then

                            docker_init_command "$@"

                        elif [[ $2 == "destroy" ]]; then

                            docker_destroy_command "$@"

                        elif [[ $2 == "clone" ]]; then

                            docker_clone_command "$@"

                        elif [[ $2 == "boot" ]]; then

                            boot_docker_command

                        elif [[ $2 == "build" ]]; then

                            docker_build_command "$@"

                        elif [[ $2 == "help" ]]; then

                            output_docker_man

                        else

                            attempt_docker_compose_commands "$@"

                        fi

                    else

                        printf "${EOL}"
                        printf "${Yellow}${INDENT}Please supply a COMMAND${NC}${EOL}"
                        output_docker_man

                    fi

                else

                    printf "${EOL}"
                    printf "${Red}${INDENT}${BOLD}Docker service not running. ${ITALIC}${BOLD}Docker OG${HAIR}${Red}${BOLD} requires the Docker service to be running.${HAIR}${NC}${SPACER}"

                fi

            else

                printf "${EOL}"
                printf "${Red}${INDENT}${BOLD}${GIT_URI} not found. ${ITALIC}${BOLD}Docker OG${HAIR}${Red}${BOLD} requires ${GIT_URI} to be installed and available in your ${ITALIC}${BOLD}PATH${HAIR}${Red}${BOLD} variable.${HAIR}${NC}${SPACER}"

            fi

        else

            printf "${EOL}"
            printf "${Red}${INDENT}${BOLD}${COMPOSE_URI} not found. ${ITALIC}${BOLD}Docker OG${HAIR}${Red}${BOLD} requires ${COMPOSE_URI} to be installed and available in your ${ITALIC}${BOLD}PATH${HAIR}${Red}${BOLD} variable or via the ${ITALIC}${BOLD}docker${HAIR}${Red}${BOLD} command.${HAIR}${NC}${SPACER}"

        fi

    else

        printf "${EOL}"
        printf "${Red}${INDENT}${BOLD}${DOCKER_URI} not found. ${ITALIC}${BOLD}Docker OG${HAIR}${Red}${BOLD} requires ${DOCKER_URI} to be installed and available in your ${ITALIC}${BOLD}PATH${HAIR}${Red}${BOLD} variable.${HAIR}${NC}${SPACER}"

    fi

}

function update_command {

    if [[ -x "$(command -v git)" ]]; then

        printf "${EOL}"
        printf "${Cyan}${INDENT}Fetching og-cli updates...${NC}${EOL}"

        cd $(dirname "$(which og)")
        git fetch

        if [[ "$(git rev-parse HEAD)" != "$(git rev-parse FETCH_HEAD)" ]]; then

            printf "${Cyan}${INDENT}Pulling latest og-cli changes...${NC}${EOL}"
            git pull

        else

            printf "${Cyan}${INDENT}No updates available${NC}${EOL}"

        fi

        printf "${EOL}"

    else

        printf "${EOL}"
        printf "${Red}${INDENT}${BOLD}${GIT_URI} not found. ${ITALIC}${BOLD}OG-CLI${HAIR}${Red}${BOLD} requires ${GIT_URI} to be installed and available in your ${ITALIC}${BOLD}PATH${HAIR}${Red}${BOLD} variable.${HAIR}${NC}${SPACER}"

    fi

}

# check for first command
if [[ $1 ]]; then

    if [[ $1 == "docker" ]]; then

        docker_command "$@"

    elif [[ $1 == "update" ]]; then

        update_command

    elif [[ $1 == "regen-hosts" ]]; then

        printf "${EOL}"
        printf "${Cyan}${INDENT}Generating host file ${ITALIC}${BOLD}/etc/hosts.d/og.conf${HAIR}${Cyan}. Maybe prompt for admin password...${NC}${EOL}"
        generate_project_hosts_file
        printf "${EOL}"

    elif [[ $1 == "help"  ]]; then

        output_man

    else

        printf "${EOL}"
        printf "${Yellow}${INDENT}COMMAND ${ITALIC}${BOLD}$1${HAIR}${Yellow}${BOLD} not found${NC}${EOL}"
        output_man

    fi

else

    printf "${EOL}"
    printf "${Yellow}${INDENT}Please supply a COMMAND${NC}${EOL}"
    output_man

fi